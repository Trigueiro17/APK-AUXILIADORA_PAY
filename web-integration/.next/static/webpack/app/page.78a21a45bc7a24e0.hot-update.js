"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/dashboard-service.ts":
/*!**************************************!*\
  !*** ./src/lib/dashboard-service.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dashboardService: function() { return /* binding */ dashboardService; },\n/* harmony export */   validateApiResponse: function() { return /* binding */ validateApiResponse; },\n/* harmony export */   validators: function() { return /* binding */ validators; }\n/* harmony export */ });\nclass DashboardService {\n    getCachedData(key) {\n        const cached = this.cache.get(key);\n        if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {\n            return cached.data;\n        }\n        return null;\n    }\n    setCachedData(key, data) {\n        this.cache.set(key, {\n            data,\n            timestamp: Date.now()\n        });\n    }\n    /**\n   * Busca métricas agregadas do dashboard\n   */ async getMetrics() {\n        const cacheKey = \"dashboard-metrics\";\n        const cached = this.getCachedData(cacheKey);\n        if (cached) return cached;\n        try {\n            const response = await fetch(\"/api/dashboard/metrics\");\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            this.setCachedData(cacheKey, data);\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching dashboard metrics:\", error);\n            // Retornar dados padrão em caso de erro\n            return {\n                totalSales: 0,\n                totalRevenue: 0,\n                dailyGoal: 0,\n                salesGrowth: 0,\n                revenueGrowth: 0,\n                goalProgress: 0\n            };\n        }\n    }\n    /**\n   * Busca dados para gráficos\n   */ async getChartData(type) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"7d\";\n        const cacheKey = \"chart-\".concat(type, \"-\").concat(period);\n        const cached = this.getCachedData(cacheKey);\n        if (cached) return cached;\n        try {\n            var _data_charts;\n            const response = await fetch(\"/api/dashboard/charts?type=\".concat(type, \"&period=\").concat(period));\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            // Extrair os dados do gráfico da estrutura retornada\n            // A API retorna {charts: {sales: {...}}} então acessamos data.charts[type]\n            const chartData = ((_data_charts = data.charts) === null || _data_charts === void 0 ? void 0 : _data_charts[type]) || data;\n            this.setCachedData(cacheKey, chartData);\n            return chartData;\n        } catch (error) {\n            console.error(\"Error fetching chart data for \".concat(type, \":\"), error);\n            return null;\n        }\n    }\n    /**\n   * Busca atividades recentes\n   */ async getRecentActivities() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, type = arguments.length > 1 ? arguments[1] : void 0;\n        const cacheKey = \"activities-\".concat(limit, \"-\").concat(type || \"all\");\n        const cached = this.getCachedData(cacheKey);\n        if (cached) return cached;\n        try {\n            const params = new URLSearchParams({\n                limit: limit.toString()\n            });\n            if (type) params.append(\"type\", type);\n            const response = await fetch(\"/api/dashboard/recent-activities?\".concat(params));\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            this.setCachedData(cacheKey, data.activities || []);\n            return data.activities || [];\n        } catch (error) {\n            console.error(\"Error fetching recent activities:\", error);\n            return [];\n        }\n    }\n    /**\n   * Busca estatísticas do sistema\n   */ async getSystemStats() {\n        const cacheKey = \"system-stats\";\n        const cached = this.getCachedData(cacheKey);\n        if (cached) return cached;\n        try {\n            const response = await fetch(\"/api/dashboard/stats\");\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            this.setCachedData(cacheKey, data);\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching system stats:\", error);\n            // Retornar dados padrão em caso de erro\n            return {\n                users: {\n                    total: 0,\n                    active: 0,\n                    inactive: 0\n                },\n                products: {\n                    total: 0,\n                    active: 0,\n                    inactive: 0\n                },\n                sales: {\n                    total: 0,\n                    today: 0,\n                    week: 0,\n                    thisMonth: 0\n                },\n                revenue: {\n                    total: 0,\n                    today: 0,\n                    week: 0,\n                    thisMonth: 0\n                },\n                system: {\n                    apiResponseTime: 0,\n                    errorRate: 0,\n                    syncStatus: \"error\",\n                    lastSync: new Date().toISOString()\n                }\n            };\n        }\n    }\n    /**\n   * Busca todos os dados do dashboard de uma vez usando o endpoint otimizado\n   */ async getDashboardData() {\n        console.log(\"\\uD83D\\uDD04 DashboardService: getDashboardData called\");\n        const cacheKey = \"complete-dashboard-data\";\n        const cached = this.getCachedData(cacheKey);\n        if (cached) {\n            console.log(\"\\uD83D\\uDCE6 DashboardService: Returning cached data:\", cached);\n            return cached;\n        }\n        try {\n            console.log(\"\\uD83C\\uDF10 DashboardService: Fetching from /api/dashboard\");\n            const response = await fetch(\"/api/dashboard\");\n            console.log(\"\\uD83D\\uDCE1 DashboardService: Response status:\", response.status);\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"✅ DashboardService: Data received:\", data);\n            // Cachear os dados por 30 segundos\n            this.setCachedData(cacheKey, data, 30000);\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching complete dashboard data:\", error);\n            // Fallback: tentar buscar dados individuais se o endpoint principal falhar\n            console.log(\"Falling back to individual API calls...\");\n            try {\n                const [metrics, stats, activities, salesChart, revenueChart, weeklyChart, paymentChart] = await Promise.allSettled([\n                    this.getMetrics(),\n                    this.getSystemStats(),\n                    this.getRecentActivities(10),\n                    this.getChartData(\"sales\", \"7d\"),\n                    this.getChartData(\"revenue\", \"7d\"),\n                    this.getChartData(\"weekly\", \"4w\"),\n                    this.getChartData(\"payment-methods\", \"30d\")\n                ]);\n                const fallbackData = {\n                    metrics: metrics.status === \"fulfilled\" ? metrics.value : {\n                        totalSales: 0,\n                        totalRevenue: 0,\n                        dailyGoal: 0,\n                        salesGrowth: 0,\n                        revenueGrowth: 0,\n                        goalProgress: 0\n                    },\n                    stats: stats.status === \"fulfilled\" ? stats.value : {\n                        users: {\n                            total: 0,\n                            active: 0,\n                            inactive: 0\n                        },\n                        products: {\n                            total: 0,\n                            active: 0,\n                            inactive: 0\n                        },\n                        sales: {\n                            total: 0,\n                            today: 0,\n                            week: 0,\n                            thisMonth: 0\n                        },\n                        revenue: {\n                            total: 0,\n                            today: 0,\n                            week: 0,\n                            thisMonth: 0\n                        },\n                        system: {\n                            apiResponseTime: 0,\n                            errorRate: 0,\n                            syncStatus: \"error\",\n                            lastSync: new Date().toISOString()\n                        }\n                    },\n                    activities: activities.status === \"fulfilled\" ? activities.value : [],\n                    charts: {\n                        sales: salesChart.status === \"fulfilled\" ? salesChart.value : null,\n                        revenue: revenueChart.status === \"fulfilled\" ? revenueChart.value : null,\n                        weekly: weeklyChart.status === \"fulfilled\" ? weeklyChart.value : null,\n                        paymentMethods: paymentChart.status === \"fulfilled\" ? paymentChart.value : null\n                    }\n                };\n                // Cachear dados do fallback por menos tempo (10 segundos)\n                this.setCachedData(cacheKey, fallbackData, 10000);\n                return fallbackData;\n            } catch (fallbackError) {\n                console.error(\"Fallback also failed:\", fallbackError);\n                throw error;\n            }\n        }\n    }\n    /**\n   * Limpa o cache\n   */ clearCache() {\n        this.cache.clear();\n    }\n    /**\n   * Força atualização dos dados (limpa cache e busca novos dados)\n   */ async refreshData() {\n        this.clearCache();\n        return this.getDashboardData();\n    }\n    /**\n   * Verifica a saúde da API\n   */ async checkApiHealth() {\n        const startTime = Date.now();\n        const errors = [];\n        try {\n            const response = await fetch(\"/api/health\");\n            const responseTime = Date.now() - startTime;\n            if (!response.ok) {\n                errors.push(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n                return {\n                    status: \"down\",\n                    responseTime,\n                    errors\n                };\n            }\n            const data = await response.json();\n            if (data.status === \"error\") {\n                errors.push(...data.errors || [\n                    \"Unknown API error\"\n                ]);\n                return {\n                    status: \"degraded\",\n                    responseTime,\n                    errors\n                };\n            }\n            return {\n                status: \"healthy\",\n                responseTime,\n                errors\n            };\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            errors.push(error instanceof Error ? error.message : \"Network error\");\n            return {\n                status: \"down\",\n                responseTime,\n                errors\n            };\n        }\n    }\n    constructor(){\n        this.cache = new Map();\n        this.CACHE_DURATION = 5 * 60 * 1000 // 5 minutos\n        ;\n    }\n}\n// Instância singleton do serviço\nconst dashboardService = new DashboardService();\n// Função utilitária para validar dados da API\nfunction validateApiResponse(data, validator) {\n    try {\n        return validator(data) ? data : null;\n    } catch (e) {\n        return null;\n    }\n}\n// Validadores de tipo\nconst validators = {\n    isDashboardMetrics: (data)=>{\n        return typeof data === \"object\" && typeof data.totalSales === \"number\" && typeof data.totalRevenue === \"number\" && typeof data.dailyGoal === \"number\";\n    },\n    isChartDataPoint: (data)=>{\n        return typeof data === \"object\" && typeof data.date === \"string\" && typeof data.value === \"number\";\n    },\n    isActivityItem: (data)=>{\n        return typeof data === \"object\" && typeof data.id === \"string\" && typeof data.type === \"string\" && typeof data.title === \"string\" && typeof data.timestamp === \"string\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGFzaGJvYXJkLXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBNENBLE1BQU1BO0lBSUlDLGNBQWlCQyxHQUFXLEVBQVk7UUFDOUMsTUFBTUMsU0FBUyxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsR0FBRyxDQUFDSDtRQUM5QixJQUFJQyxVQUFVRyxLQUFLQyxHQUFHLEtBQUtKLE9BQU9LLFNBQVMsR0FBRyxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUNqRSxPQUFPTixPQUFPTyxJQUFJO1FBQ3BCO1FBQ0EsT0FBTztJQUNUO0lBRVFDLGNBQWlCVCxHQUFXLEVBQUVRLElBQU8sRUFBUTtRQUNuRCxJQUFJLENBQUNOLEtBQUssQ0FBQ1EsR0FBRyxDQUFDVixLQUFLO1lBQUVRO1lBQU1GLFdBQVdGLEtBQUtDLEdBQUc7UUFBRztJQUNwRDtJQUVBOztHQUVDLEdBQ0QsTUFBTU0sYUFBd0M7UUFDNUMsTUFBTUMsV0FBVztRQUNqQixNQUFNWCxTQUFTLElBQUksQ0FBQ0YsYUFBYSxDQUFtQmE7UUFDcEQsSUFBSVgsUUFBUSxPQUFPQTtRQUVuQixJQUFJO1lBQ0YsTUFBTVksV0FBVyxNQUFNQyxNQUFNO1lBQzdCLElBQUksQ0FBQ0QsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlDLE1BQU0sdUJBQXVDLE9BQWhCSCxTQUFTSSxNQUFNO1lBQ3hEO1lBQ0EsTUFBTVQsT0FBTyxNQUFNSyxTQUFTSyxJQUFJO1lBQ2hDLElBQUksQ0FBQ1QsYUFBYSxDQUFDRyxVQUFVSjtZQUM3QixPQUFPQTtRQUNULEVBQUUsT0FBT1csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCx3Q0FBd0M7WUFDeEMsT0FBTztnQkFDTEUsWUFBWTtnQkFDWkMsY0FBYztnQkFDZEMsV0FBVztnQkFDWEMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsY0FBYztZQUNoQjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNE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bkM7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZGFzaGJvYXJkLXNlcnZpY2UudHM/NGM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhdXhpbGlhZG9yYUFwaUNsaWVudCB9IGZyb20gJy4vYXBpLWNsaWVudCc7XG5pbXBvcnQgdHlwZSB7IERhc2hib2FyZFN0YXRzIH0gZnJvbSAnQC90eXBlcyc7XG5cbi8vIFRpcG9zIHBhcmEgb3MgZGFkb3MgZG8gZGFzaGJvYXJkXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZE1ldHJpY3Mge1xuICB0b3RhbFNhbGVzOiBudW1iZXI7XG4gIHRvdGFsUmV2ZW51ZTogbnVtYmVyO1xuICBkYWlseUdvYWw6IG51bWJlcjtcbiAgc2FsZXNHcm93dGg6IG51bWJlcjtcbiAgcmV2ZW51ZUdyb3d0aDogbnVtYmVyO1xuICBnb2FsUHJvZ3Jlc3M6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydERhdGFQb2ludCB7XG4gIGRhdGU6IHN0cmluZztcbiAgdmFsdWU6IG51bWJlcjtcbiAgbGFiZWw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlJdGVtIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogJ3NhbGUnIHwgJ3VzZXInIHwgJ3Byb2R1Y3QnIHwgJ3N5c3RlbSc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBhbW91bnQ/OiBudW1iZXI7XG4gIHN0YXR1cz86ICdzdWNjZXNzJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnaW5mbyc7XG4gIHVzZXI/OiBzdHJpbmc7XG4gIGRldGFpbHM/OiBzdHJpbmc7XG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmREYXRhIHtcbiAgbWV0cmljczogRGFzaGJvYXJkTWV0cmljcztcbiAgY2hhcnRzOiB7XG4gICAgc2FsZXM6IENoYXJ0RGF0YVBvaW50W107XG4gICAgcmV2ZW51ZTogQ2hhcnREYXRhUG9pbnRbXTtcbiAgICB3ZWVrbHk6IENoYXJ0RGF0YVBvaW50W107XG4gICAgcGF5bWVudE1ldGhvZHM6IENoYXJ0RGF0YVBvaW50W107XG4gIH07XG4gIGFjdGl2aXRpZXM6IEFjdGl2aXR5SXRlbVtdO1xuICBzdGF0czogRGFzaGJvYXJkU3RhdHM7XG59XG5cbmNsYXNzIERhc2hib2FyZFNlcnZpY2Uge1xuICBwcml2YXRlIGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIHsgZGF0YTogYW55OyB0aW1lc3RhbXA6IG51bWJlciB9PigpO1xuICBwcml2YXRlIHJlYWRvbmx5IENBQ0hFX0RVUkFUSU9OID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dG9zXG5cbiAgcHJpdmF0ZSBnZXRDYWNoZWREYXRhPFQ+KGtleTogc3RyaW5nKTogVCB8IG51bGwge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGNhY2hlZCAmJiBEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA8IHRoaXMuQ0FDSEVfRFVSQVRJT04pIHtcbiAgICAgIHJldHVybiBjYWNoZWQuZGF0YSBhcyBUO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Q2FjaGVkRGF0YTxUPihrZXk6IHN0cmluZywgZGF0YTogVCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgeyBkYXRhLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgbcOpdHJpY2FzIGFncmVnYWRhcyBkbyBkYXNoYm9hcmRcbiAgICovXG4gIGFzeW5jIGdldE1ldHJpY3MoKTogUHJvbWlzZTxEYXNoYm9hcmRNZXRyaWNzPiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSAnZGFzaGJvYXJkLW1ldHJpY3MnO1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkRGF0YTxEYXNoYm9hcmRNZXRyaWNzPihjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2Rhc2hib2FyZC9tZXRyaWNzJyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB0aGlzLnNldENhY2hlZERhdGEoY2FjaGVLZXksIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhc2hib2FyZCBtZXRyaWNzOicsIGVycm9yKTtcbiAgICAgIC8vIFJldG9ybmFyIGRhZG9zIHBhZHLDo28gZW0gY2FzbyBkZSBlcnJvXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbFNhbGVzOiAwLFxuICAgICAgICB0b3RhbFJldmVudWU6IDAsXG4gICAgICAgIGRhaWx5R29hbDogMCxcbiAgICAgICAgc2FsZXNHcm93dGg6IDAsXG4gICAgICAgIHJldmVudWVHcm93dGg6IDAsXG4gICAgICAgIGdvYWxQcm9ncmVzczogMFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgZGFkb3MgcGFyYSBncsOhZmljb3NcbiAgICovXG4gIGFzeW5jIGdldENoYXJ0RGF0YSh0eXBlOiAnc2FsZXMnIHwgJ3JldmVudWUnIHwgJ3dlZWtseScgfCAncGF5bWVudC1tZXRob2RzJywgcGVyaW9kOiBzdHJpbmcgPSAnN2QnKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGBjaGFydC0ke3R5cGV9LSR7cGVyaW9kfWA7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWREYXRhPGFueT4oY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXNoYm9hcmQvY2hhcnRzP3R5cGU9JHt0eXBlfSZwZXJpb2Q9JHtwZXJpb2R9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAvLyBFeHRyYWlyIG9zIGRhZG9zIGRvIGdyw6FmaWNvIGRhIGVzdHJ1dHVyYSByZXRvcm5hZGFcbiAgICAgIC8vIEEgQVBJIHJldG9ybmEge2NoYXJ0czoge3NhbGVzOiB7Li4ufX19IGVudMOjbyBhY2Vzc2Ftb3MgZGF0YS5jaGFydHNbdHlwZV1cbiAgICAgIGNvbnN0IGNoYXJ0RGF0YSA9IGRhdGEuY2hhcnRzPy5bdHlwZV0gfHwgZGF0YTtcbiAgICAgIHRoaXMuc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgY2hhcnREYXRhKTtcbiAgICAgIHJldHVybiBjaGFydERhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoYXJ0IGRhdGEgZm9yICR7dHlwZX06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1c2NhIGF0aXZpZGFkZXMgcmVjZW50ZXNcbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEFjdGl2aXRpZXMobGltaXQ6IG51bWJlciA9IDEwLCB0eXBlPzogc3RyaW5nKTogUHJvbWlzZTxBY3Rpdml0eUl0ZW1bXT4ge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFjdGl2aXRpZXMtJHtsaW1pdH0tJHt0eXBlIHx8ICdhbGwnfWA7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWREYXRhPEFjdGl2aXR5SXRlbVtdPihjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCkgfSk7XG4gICAgICBpZiAodHlwZSkgcGFyYW1zLmFwcGVuZCgndHlwZScsIHR5cGUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2Rhc2hib2FyZC9yZWNlbnQtYWN0aXZpdGllcz8ke3BhcmFtc31gKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHRoaXMuc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgZGF0YS5hY3Rpdml0aWVzIHx8IFtdKTtcbiAgICAgIHJldHVybiBkYXRhLmFjdGl2aXRpZXMgfHwgW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlY2VudCBhY3Rpdml0aWVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgZXN0YXTDrXN0aWNhcyBkbyBzaXN0ZW1hXG4gICAqL1xuICBhc3luYyBnZXRTeXN0ZW1TdGF0cygpOiBQcm9taXNlPERhc2hib2FyZFN0YXRzPiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSAnc3lzdGVtLXN0YXRzJztcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmdldENhY2hlZERhdGE8RGFzaGJvYXJkU3RhdHM+KGNhY2hlS2V5KTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZGFzaGJvYXJkL3N0YXRzJyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB0aGlzLnNldENhY2hlZERhdGEoY2FjaGVLZXksIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHN5c3RlbSBzdGF0czonLCBlcnJvcik7XG4gICAgICAvLyBSZXRvcm5hciBkYWRvcyBwYWRyw6NvIGVtIGNhc28gZGUgZXJyb1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcnM6IHsgdG90YWw6IDAsIGFjdGl2ZTogMCwgaW5hY3RpdmU6IDAgfSxcbiAgICAgICAgcHJvZHVjdHM6IHsgdG90YWw6IDAsIGFjdGl2ZTogMCwgaW5hY3RpdmU6IDAgfSxcbiAgICAgICAgc2FsZXM6IHsgdG90YWw6IDAsIHRvZGF5OiAwLCB3ZWVrOiAwLCB0aGlzTW9udGg6IDAgfSxcbiAgICAgICAgcmV2ZW51ZTogeyB0b3RhbDogMCwgdG9kYXk6IDAsIHdlZWs6IDAsIHRoaXNNb250aDogMCB9LFxuICAgICAgICBzeXN0ZW06IHtcbiAgICAgICAgICBhcGlSZXNwb25zZVRpbWU6IDAsXG4gICAgICAgICAgZXJyb3JSYXRlOiAwLFxuICAgICAgICAgIHN5bmNTdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbGFzdFN5bmM6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSB0b2RvcyBvcyBkYWRvcyBkbyBkYXNoYm9hcmQgZGUgdW1hIHZleiB1c2FuZG8gbyBlbmRwb2ludCBvdGltaXphZG9cbiAgICovXG4gIGFzeW5jIGdldERhc2hib2FyZERhdGEoKTogUHJvbWlzZTxEYXNoYm9hcmREYXRhPiB7XG4gICAgY29uc29sZS5sb2coJ/CflIQgRGFzaGJvYXJkU2VydmljZTogZ2V0RGFzaGJvYXJkRGF0YSBjYWxsZWQnKTtcbiAgICBjb25zdCBjYWNoZUtleSA9ICdjb21wbGV0ZS1kYXNoYm9hcmQtZGF0YSc7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWREYXRhPERhc2hib2FyZERhdGE+KGNhY2hlS2V5KTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TpiBEYXNoYm9hcmRTZXJ2aWNlOiBSZXR1cm5pbmcgY2FjaGVkIGRhdGE6JywgY2FjaGVkKTtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4yQIERhc2hib2FyZFNlcnZpY2U6IEZldGNoaW5nIGZyb20gL2FwaS9kYXNoYm9hcmQnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZGFzaGJvYXJkJyk7XG4gICAgICBjb25zb2xlLmxvZygn8J+ToSBEYXNoYm9hcmRTZXJ2aWNlOiBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRGFzaGJvYXJkU2VydmljZTogRGF0YSByZWNlaXZlZDonLCBkYXRhKTtcbiAgICAgIFxuICAgICAgLy8gQ2FjaGVhciBvcyBkYWRvcyBwb3IgMzAgc2VndW5kb3NcbiAgICAgIHRoaXMuc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgZGF0YSwgMzAwMDApO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvbXBsZXRlIGRhc2hib2FyZCBkYXRhOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2s6IHRlbnRhciBidXNjYXIgZGFkb3MgaW5kaXZpZHVhaXMgc2UgbyBlbmRwb2ludCBwcmluY2lwYWwgZmFsaGFyXG4gICAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIGluZGl2aWR1YWwgQVBJIGNhbGxzLi4uJyk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbbWV0cmljcywgc3RhdHMsIGFjdGl2aXRpZXMsIHNhbGVzQ2hhcnQsIHJldmVudWVDaGFydCwgd2Vla2x5Q2hhcnQsIHBheW1lbnRDaGFydF0gPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xuICAgICAgICAgIHRoaXMuZ2V0TWV0cmljcygpLFxuICAgICAgICAgIHRoaXMuZ2V0U3lzdGVtU3RhdHMoKSxcbiAgICAgICAgICB0aGlzLmdldFJlY2VudEFjdGl2aXRpZXMoMTApLFxuICAgICAgICAgIHRoaXMuZ2V0Q2hhcnREYXRhKCdzYWxlcycsICc3ZCcpLFxuICAgICAgICAgIHRoaXMuZ2V0Q2hhcnREYXRhKCdyZXZlbnVlJywgJzdkJyksXG4gICAgICAgICAgdGhpcy5nZXRDaGFydERhdGEoJ3dlZWtseScsICc0dycpLFxuICAgICAgICAgIHRoaXMuZ2V0Q2hhcnREYXRhKCdwYXltZW50LW1ldGhvZHMnLCAnMzBkJylcbiAgICAgICAgXSk7XG5cbiAgICAgICAgY29uc3QgZmFsbGJhY2tEYXRhID0ge1xuICAgICAgICAgIG1ldHJpY3M6IG1ldHJpY3Muc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IG1ldHJpY3MudmFsdWUgOiB7XG4gICAgICAgICAgICB0b3RhbFNhbGVzOiAwLFxuICAgICAgICAgICAgdG90YWxSZXZlbnVlOiAwLFxuICAgICAgICAgICAgZGFpbHlHb2FsOiAwLFxuICAgICAgICAgICAgc2FsZXNHcm93dGg6IDAsXG4gICAgICAgICAgICByZXZlbnVlR3Jvd3RoOiAwLFxuICAgICAgICAgICAgZ29hbFByb2dyZXNzOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGF0czogc3RhdHMuc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IHN0YXRzLnZhbHVlIDoge1xuICAgICAgICAgICAgdXNlcnM6IHsgdG90YWw6IDAsIGFjdGl2ZTogMCwgaW5hY3RpdmU6IDAgfSxcbiAgICAgICAgICAgIHByb2R1Y3RzOiB7IHRvdGFsOiAwLCBhY3RpdmU6IDAsIGluYWN0aXZlOiAwIH0sXG4gICAgICAgICAgICBzYWxlczogeyB0b3RhbDogMCwgdG9kYXk6IDAsIHdlZWs6IDAsIHRoaXNNb250aDogMCB9LFxuICAgICAgICAgICAgcmV2ZW51ZTogeyB0b3RhbDogMCwgdG9kYXk6IDAsIHdlZWs6IDAsIHRoaXNNb250aDogMCB9LFxuICAgICAgICAgICAgc3lzdGVtOiB7XG4gICAgICAgICAgICAgIGFwaVJlc3BvbnNlVGltZTogMCxcbiAgICAgICAgICAgICAgZXJyb3JSYXRlOiAwLFxuICAgICAgICAgICAgICBzeW5jU3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgICBsYXN0U3luYzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhY3Rpdml0aWVzOiBhY3Rpdml0aWVzLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyBhY3Rpdml0aWVzLnZhbHVlIDogW10sXG4gICAgICAgICAgY2hhcnRzOiB7XG4gICAgICAgICAgICBzYWxlczogc2FsZXNDaGFydC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnID8gc2FsZXNDaGFydC52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICByZXZlbnVlOiByZXZlbnVlQ2hhcnQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IHJldmVudWVDaGFydC52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICB3ZWVrbHk6IHdlZWtseUNoYXJ0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyB3ZWVrbHlDaGFydC52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICBwYXltZW50TWV0aG9kczogcGF5bWVudENoYXJ0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyBwYXltZW50Q2hhcnQudmFsdWUgOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FjaGVhciBkYWRvcyBkbyBmYWxsYmFjayBwb3IgbWVub3MgdGVtcG8gKDEwIHNlZ3VuZG9zKVxuICAgICAgICB0aGlzLnNldENhY2hlZERhdGEoY2FjaGVLZXksIGZhbGxiYWNrRGF0YSwgMTAwMDApO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tEYXRhO1xuICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWxsYmFjayBhbHNvIGZhaWxlZDonLCBmYWxsYmFja0Vycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpbXBhIG8gY2FjaGVcbiAgICovXG4gIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcsOnYSBhdHVhbGl6YcOnw6NvIGRvcyBkYWRvcyAobGltcGEgY2FjaGUgZSBidXNjYSBub3ZvcyBkYWRvcylcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hEYXRhKCk6IFByb21pc2U8RGFzaGJvYXJkRGF0YT4ge1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLmdldERhc2hib2FyZERhdGEoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBhIHNhw7pkZSBkYSBBUElcbiAgICovXG4gIGFzeW5jIGNoZWNrQXBpSGVhbHRoKCk6IFByb21pc2U8eyBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAnZG93bic7IHJlc3BvbnNlVGltZTogbnVtYmVyOyBlcnJvcnM6IHN0cmluZ1tdIH0+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9oZWFsdGgnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Rvd24nLCByZXNwb25zZVRpbWUsIGVycm9ycyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uKGRhdGEuZXJyb3JzIHx8IFsnVW5rbm93biBBUEkgZXJyb3InXSkpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdkZWdyYWRlZCcsIHJlc3BvbnNlVGltZSwgZXJyb3JzIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2hlYWx0aHknLCByZXNwb25zZVRpbWUsIGVycm9ycyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgZXJyb3JzLnB1c2goZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnTmV0d29yayBlcnJvcicpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZG93bicsIHJlc3BvbnNlVGltZSwgZXJyb3JzIH07XG4gICAgfVxuICB9XG59XG5cbi8vIEluc3TDom5jaWEgc2luZ2xldG9uIGRvIHNlcnZpw6dvXG5leHBvcnQgY29uc3QgZGFzaGJvYXJkU2VydmljZSA9IG5ldyBEYXNoYm9hcmRTZXJ2aWNlKCk7XG5cbi8vIEZ1bsOnw6NvIHV0aWxpdMOhcmlhIHBhcmEgdmFsaWRhciBkYWRvcyBkYSBBUElcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFwaVJlc3BvbnNlPFQ+KGRhdGE6IGFueSwgdmFsaWRhdG9yOiAoZGF0YTogYW55KSA9PiBkYXRhIGlzIFQpOiBUIHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcihkYXRhKSA/IGRhdGEgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBWYWxpZGFkb3JlcyBkZSB0aXBvXG5leHBvcnQgY29uc3QgdmFsaWRhdG9ycyA9IHtcbiAgaXNEYXNoYm9hcmRNZXRyaWNzOiAoZGF0YTogYW55KTogZGF0YSBpcyBEYXNoYm9hcmRNZXRyaWNzID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgIHR5cGVvZiBkYXRhLnRvdGFsU2FsZXMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIHR5cGVvZiBkYXRhLnRvdGFsUmV2ZW51ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgdHlwZW9mIGRhdGEuZGFpbHlHb2FsID09PSAnbnVtYmVyJztcbiAgfSxcbiAgXG4gIGlzQ2hhcnREYXRhUG9pbnQ6IChkYXRhOiBhbnkpOiBkYXRhIGlzIENoYXJ0RGF0YVBvaW50ID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgIHR5cGVvZiBkYXRhLmRhdGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgIHR5cGVvZiBkYXRhLnZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgXG4gIGlzQWN0aXZpdHlJdGVtOiAoZGF0YTogYW55KTogZGF0YSBpcyBBY3Rpdml0eUl0ZW0gPT4ge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgdHlwZW9mIGRhdGEuaWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgIHR5cGVvZiBkYXRhLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgIHR5cGVvZiBkYXRhLnRpdGxlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICB0eXBlb2YgZGF0YS50aW1lc3RhbXAgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG4vLyBFeHBvcnRhciB0aXBvcyBwYXJhIHVzbyBlbSBvdXRyb3MgYXJxdWl2b3NcbmV4cG9ydCB0eXBlIHsgRGFzaGJvYXJkRGF0YSwgRGFzaGJvYXJkTWV0cmljcywgQ2hhcnREYXRhUG9pbnQsIEFjdGl2aXR5SXRlbSB9OyJdLCJuYW1lcyI6WyJEYXNoYm9hcmRTZXJ2aWNlIiwiZ2V0Q2FjaGVkRGF0YSIsImtleSIsImNhY2hlZCIsImNhY2hlIiwiZ2V0IiwiRGF0ZSIsIm5vdyIsInRpbWVzdGFtcCIsIkNBQ0hFX0RVUkFUSU9OIiwiZGF0YSIsInNldENhY2hlZERhdGEiLCJzZXQiLCJnZXRNZXRyaWNzIiwiY2FjaGVLZXkiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJ0b3RhbFNhbGVzIiwidG90YWxSZXZlbnVlIiwiZGFpbHlHb2FsIiwic2FsZXNHcm93dGgiLCJyZXZlbnVlR3Jvd3RoIiwiZ29hbFByb2dyZXNzIiwiZ2V0Q2hhcnREYXRhIiwidHlwZSIsInBlcmlvZCIsImNoYXJ0RGF0YSIsImNoYXJ0cyIsImdldFJlY2VudEFjdGl2aXRpZXMiLCJsaW1pdCIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwiYXBwZW5kIiwiYWN0aXZpdGllcyIsImdldFN5c3RlbVN0YXRzIiwidXNlcnMiLCJ0b3RhbCIsImFjdGl2ZSIsImluYWN0aXZlIiwicHJvZHVjdHMiLCJzYWxlcyIsInRvZGF5Iiwid2VlayIsInRoaXNNb250aCIsInJldmVudWUiLCJzeXN0ZW0iLCJhcGlSZXNwb25zZVRpbWUiLCJlcnJvclJhdGUiLCJzeW5jU3RhdHVzIiwibGFzdFN5bmMiLCJ0b0lTT1N0cmluZyIsImdldERhc2hib2FyZERhdGEiLCJsb2ciLCJtZXRyaWNzIiwic3RhdHMiLCJzYWxlc0NoYXJ0IiwicmV2ZW51ZUNoYXJ0Iiwid2Vla2x5Q2hhcnQiLCJwYXltZW50Q2hhcnQiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsImZhbGxiYWNrRGF0YSIsInZhbHVlIiwid2Vla2x5IiwicGF5bWVudE1ldGhvZHMiLCJmYWxsYmFja0Vycm9yIiwiY2xlYXJDYWNoZSIsImNsZWFyIiwicmVmcmVzaERhdGEiLCJjaGVja0FwaUhlYWx0aCIsInN0YXJ0VGltZSIsImVycm9ycyIsInJlc3BvbnNlVGltZSIsInB1c2giLCJzdGF0dXNUZXh0IiwibWVzc2FnZSIsIk1hcCIsImRhc2hib2FyZFNlcnZpY2UiLCJ2YWxpZGF0ZUFwaVJlc3BvbnNlIiwidmFsaWRhdG9yIiwidmFsaWRhdG9ycyIsImlzRGFzaGJvYXJkTWV0cmljcyIsImlzQ2hhcnREYXRhUG9pbnQiLCJkYXRlIiwiaXNBY3Rpdml0eUl0ZW0iLCJpZCIsInRpdGxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/dashboard-service.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/cash-registers/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\nconst API_BASE_URL = \"/api\";\n// API Client\nclass ApiClient {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const url = \"\".concat(this.baseUrl).concat(endpoint);\n        const config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...options.headers\n            },\n            ...options\n        };\n        try {\n            const response = await fetch(url, config);\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"API request failed: \".concat(url), error);\n            throw error;\n        }\n    }\n    // Users API\n    async getUsers() {\n        return this.request(\"/users\");\n    }\n    async createUser(userData) {\n        return this.request(\"/users\", {\n            method: \"POST\",\n            body: JSON.stringify(userData)\n        });\n    }\n    async getUserById(id) {\n        return this.request(\"/users/\".concat(id));\n    }\n    async updateUser(id, userData) {\n        return this.request(\"/users/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(userData)\n        });\n    }\n    async deleteUser(id) {\n        return this.request(\"/users/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    // Products API\n    async getProducts(active) {\n        const query = active !== undefined ? \"?active=\".concat(active) : \"\";\n        return this.request(\"/products\".concat(query));\n    }\n    async createProduct(productData) {\n        return this.request(\"/products\", {\n            method: \"POST\",\n            body: JSON.stringify(productData)\n        });\n    }\n    async getProductById(id) {\n        return this.request(\"/products/\".concat(id));\n    }\n    async updateProduct(id, productData) {\n        return this.request(\"/products/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(productData)\n        });\n    }\n    async deleteProduct(id) {\n        return this.request(\"/products/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    // Cash Registers\n    async getCashRegisters(params) {\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.status) queryParams.append(\"status\", params.status);\n        if (params === null || params === void 0 ? void 0 : params.userId) queryParams.append(\"userId\", params.userId);\n        const url = \"/cash-registers\".concat(queryParams.toString() ? \"?\".concat(queryParams.toString()) : \"\");\n        return this.request(url);\n    }\n    async getCashRegister(id) {\n        return this.request(\"/cash-registers/\".concat(id));\n    }\n    async createCashRegister(data) {\n        return this.request(\"/cash-registers\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async updateCashRegister(id, data) {\n        return this.request(\"/cash-registers/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(data)\n        });\n    }\n    async deleteCashRegister(id) {\n        return this.request(\"/cash-registers/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    // Sales API\n    async getSales(filters) {\n        const params = new URLSearchParams();\n        if (filters) {\n            Object.entries(filters).forEach((param)=>{\n                let [key, value] = param;\n                if (value) params.append(key, value);\n            });\n        }\n        const query = params.toString() ? \"?\".concat(params.toString()) : \"\";\n        return this.request(\"/sales\".concat(query));\n    }\n    async createSale(saleData) {\n        return this.request(\"/sales\", {\n            method: \"POST\",\n            body: JSON.stringify(saleData)\n        });\n    }\n    async getSaleById(id) {\n        return this.request(\"/sales/\".concat(id));\n    }\n    async updateSale(id, saleData) {\n        return this.request(\"/sales/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(saleData)\n        });\n    }\n    async deleteSale(id) {\n        return this.request(\"/sales/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    constructor(baseUrl){\n        this.baseUrl = baseUrl;\n    }\n}\n// Export singleton instance\nconst apiClient = new ApiClient(API_BASE_URL);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0ssUUFBUSxNQUFPO1FBQzVELE9BQU8sSUFBSSxDQUFDekMsT0FBTyxDQUFTLFNBQWUsT0FBTjRCO0lBQ3ZDO0lBRUEsTUFBTTBCLFdBQVdDLFFBT2hCLEVBQWlCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDdkQsT0FBTyxDQUFPLFVBQVU7WUFDbENrQixRQUFRO1lBQ1JDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ2tDO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNQyxZQUFZakMsRUFBVSxFQUFpQjtRQUMzQyxPQUFPLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBTyxVQUFhLE9BQUh1QjtJQUN0QztJQUVBLE1BQU1rQyxXQUFXbEMsRUFBVSxFQUFFZ0MsUUFBK0QsRUFBaUI7UUFDM0csT0FBTyxJQUFJLENBQUN2RCxPQUFPLENBQU8sVUFBYSxPQUFIdUIsS0FBTTtZQUN4Q0wsUUFBUTtZQUNSQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNrQztRQUN2QjtJQUNGO0lBRUEsTUFBTUcsV0FBV25DLEVBQVUsRUFBaUI7UUFDMUMsT0FBTyxJQUFJLENBQUN2QixPQUFPLENBQU8sVUFBYSxPQUFIdUIsS0FBTTtZQUN4Q0wsUUFBUTtRQUNWO0lBQ0Y7SUE3S0F5QyxZQUFZdkQsT0FBZSxDQUFFO1FBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtBQTRLRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNd0QsWUFBWSxJQUFJN0QsVUFBVUQsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS50cz8yZmFiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFQSV9CQVNFX1VSTCA9ICcvYXBpJztcblxuLy8gVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcm9sZTogJ1VTRVInIHwgJ0FETUlOJztcbiAgYWN0aXZlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjdCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHByaWNlOiBudW1iZXI7XG4gIGltYWdlVXJpPzogc3RyaW5nO1xuICBhY3RpdmU6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICB1cGRhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXNoUmVnaXN0ZXIge1xuICBpZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgc3RhdHVzOiAnT1BFTicgfCAnQ0xPU0VEJztcbiAgaW5pdGlhbEFtb3VudDogbnVtYmVyO1xuICBjdXJyZW50QW1vdW50OiBudW1iZXI7XG4gIGZpbmFsQW1vdW50OiBudW1iZXIgfCBudWxsO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQ2FzaFJlZ2lzdGVyUmVxdWVzdCB7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBpbml0aWFsQW1vdW50PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUNhc2hSZWdpc3RlclJlcXVlc3Qge1xuICBzdGF0dXM/OiAnT1BFTicgfCAnQ0xPU0VEJztcbiAgY3VycmVudEFtb3VudD86IG51bWJlcjtcbiAgZmluYWxBbW91bnQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2FsZUl0ZW0ge1xuICBwcm9kdWN0SWQ6IHN0cmluZztcbiAgcHJvZHVjdE5hbWU6IHN0cmluZztcbiAgcXVhbnRpdHk6IG51bWJlcjtcbiAgcHJpY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTYWxlIHtcbiAgaWQ6IHN0cmluZztcbiAgY2FzaFJlZ2lzdGVySWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIGl0ZW1zOiBTYWxlSXRlbVtdO1xuICB0b3RhbDogbnVtYmVyO1xuICBwYXltZW50TWV0aG9kOiAnQ0FTSCcgfCAnQ0FSRCcgfCAnUElYJztcbiAgc3RhdHVzOiAnUEVORElORycgfCAnQ09NUExFVEVEJyB8ICdDQU5DRUxMRUQnO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG4gIHVzZXI/OiBVc2VyO1xuICBjYXNoUmVnaXN0ZXI/OiBDYXNoUmVnaXN0ZXI7XG59XG5cbi8vIEFQSSBDbGllbnRcbmNsYXNzIEFwaUNsaWVudCB7XG4gIHByaXZhdGUgYmFzZVVybDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGJhc2VVcmw6IHN0cmluZykge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XG4gICk6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2VuZHBvaW50fWA7XG4gICAgXG4gICAgY29uc3QgY29uZmlnOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgY29uZmlnKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHt1cmx9YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlcnMgQVBJXG4gIGFzeW5jIGdldFVzZXJzKCk6IFByb21pc2U8VXNlcltdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxVc2VyW10+KCcvdXNlcnMnKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVVzZXIodXNlckRhdGE6IE9taXQ8VXNlciwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+KTogUHJvbWlzZTxVc2VyPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxVc2VyPignL3VzZXJzJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRVc2VyQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxVc2VyPihgL3VzZXJzLyR7aWR9YCk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVVc2VyKGlkOiBzdHJpbmcsIHVzZXJEYXRhOiBQYXJ0aWFsPE9taXQ8VXNlciwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+Pik6IFByb21pc2U8VXNlcj4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VXNlcj4oYC91c2Vycy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBkZWxldGVVc2VyKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PHZvaWQ+KGAvdXNlcnMvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUHJvZHVjdHMgQVBJXG4gIGFzeW5jIGdldFByb2R1Y3RzKGFjdGl2ZT86IGJvb2xlYW4pOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYWN0aXZlICE9PSB1bmRlZmluZWQgPyBgP2FjdGl2ZT0ke2FjdGl2ZX1gIDogJyc7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxQcm9kdWN0W10+KGAvcHJvZHVjdHMke3F1ZXJ5fWApO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlUHJvZHVjdChwcm9kdWN0RGF0YTogT21pdDxQcm9kdWN0LCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4pOiBQcm9taXNlPFByb2R1Y3Q+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFByb2R1Y3Q+KCcvcHJvZHVjdHMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2R1Y3REYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldFByb2R1Y3RCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3Q+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFByb2R1Y3Q+KGAvcHJvZHVjdHMvJHtpZH1gKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2R1Y3QoaWQ6IHN0cmluZywgcHJvZHVjdERhdGE6IFBhcnRpYWw8T21pdDxQcm9kdWN0LCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4+KTogUHJvbWlzZTxQcm9kdWN0PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxQcm9kdWN0PihgL3Byb2R1Y3RzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2R1Y3REYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVByb2R1Y3QoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8dm9pZD4oYC9wcm9kdWN0cy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDYXNoIFJlZ2lzdGVyc1xuICBhc3luYyBnZXRDYXNoUmVnaXN0ZXJzKHBhcmFtcz86IHsgc3RhdHVzPzogJ09QRU4nIHwgJ0NMT1NFRCc7IHVzZXJJZD86IHN0cmluZyB9KTogUHJvbWlzZTxDYXNoUmVnaXN0ZXJbXT4ge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChwYXJhbXM/LnN0YXR1cykgcXVlcnlQYXJhbXMuYXBwZW5kKCdzdGF0dXMnLCBwYXJhbXMuc3RhdHVzKTtcbiAgICBpZiAocGFyYW1zPy51c2VySWQpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgndXNlcklkJywgcGFyYW1zLnVzZXJJZCk7XG4gICAgXG4gICAgY29uc3QgdXJsID0gYC9jYXNoLXJlZ2lzdGVycyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWAgOiAnJ31gO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8Q2FzaFJlZ2lzdGVyW10+KHVybCk7XG4gIH1cblxuICBhc3luYyBnZXRDYXNoUmVnaXN0ZXIoaWQ6IHN0cmluZyk6IFByb21pc2U8Q2FzaFJlZ2lzdGVyPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxDYXNoUmVnaXN0ZXI+KGAvY2FzaC1yZWdpc3RlcnMvJHtpZH1gKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUNhc2hSZWdpc3RlcihkYXRhOiBDcmVhdGVDYXNoUmVnaXN0ZXJSZXF1ZXN0KTogUHJvbWlzZTxDYXNoUmVnaXN0ZXI+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PENhc2hSZWdpc3Rlcj4oJy9jYXNoLXJlZ2lzdGVycycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVDYXNoUmVnaXN0ZXIoaWQ6IHN0cmluZywgZGF0YTogVXBkYXRlQ2FzaFJlZ2lzdGVyUmVxdWVzdCk6IFByb21pc2U8Q2FzaFJlZ2lzdGVyPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxDYXNoUmVnaXN0ZXI+KGAvY2FzaC1yZWdpc3RlcnMvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBkZWxldGVDYXNoUmVnaXN0ZXIoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8dm9pZD4oYC9jYXNoLXJlZ2lzdGVycy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgfSk7XG4gIH1cblxuICAvLyBTYWxlcyBBUElcbiAgYXN5bmMgZ2V0U2FsZXMoZmlsdGVycz86IHtcbiAgICBzdGF0dXM/OiAnUEVORElORycgfCAnQ09NUExFVEVEJyB8ICdDQU5DRUxMRUQnO1xuICAgIHVzZXJJZD86IHN0cmluZztcbiAgICBjYXNoUmVnaXN0ZXJJZD86IHN0cmluZztcbiAgICBwYXltZW50TWV0aG9kPzogJ0NBU0gnIHwgJ0NBUkQnIHwgJ1BJWCc7XG4gICAgc3RhcnREYXRlPzogc3RyaW5nO1xuICAgIGVuZERhdGU/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFNhbGVbXT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoZmlsdGVycykge1xuICAgICAgT2JqZWN0LmVudHJpZXMoZmlsdGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSkgcGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHBhcmFtcy50b1N0cmluZygpID8gYD8ke3BhcmFtcy50b1N0cmluZygpfWAgOiAnJztcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFNhbGVbXT4oYC9zYWxlcyR7cXVlcnl9YCk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVTYWxlKHNhbGVEYXRhOiB7XG4gICAgY2FzaFJlZ2lzdGVySWQ6IHN0cmluZztcbiAgICB1c2VySWQ6IHN0cmluZztcbiAgICBpdGVtczogU2FsZUl0ZW1bXTtcbiAgICB0b3RhbDogbnVtYmVyO1xuICAgIHBheW1lbnRNZXRob2Q6ICdDQVNIJyB8ICdDQVJEJyB8ICdQSVgnO1xuICAgIHN0YXR1cz86ICdQRU5ESU5HJyB8ICdDT01QTEVURUQnIHwgJ0NBTkNFTExFRCc7XG4gIH0pOiBQcm9taXNlPFNhbGU+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFNhbGU+KCcvc2FsZXMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNhbGVEYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldFNhbGVCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFNhbGU+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFNhbGU+KGAvc2FsZXMvJHtpZH1gKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVNhbGUoaWQ6IHN0cmluZywgc2FsZURhdGE6IFBhcnRpYWw8T21pdDxTYWxlLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4+KTogUHJvbWlzZTxTYWxlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxTYWxlPihgL3NhbGVzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNhbGVEYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNhbGUoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8dm9pZD4oYC9zYWxlcy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGFwaUNsaWVudCA9IG5ldyBBcGlDbGllbnQoQVBJX0JBU0VfVVJMKTsiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwiQXBpQ2xpZW50IiwicmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsImJhc2VVcmwiLCJjb25maWciLCJoZWFkZXJzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0VXNlcnMiLCJjcmVhdGVVc2VyIiwidXNlckRhdGEiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFVzZXJCeUlkIiwiaWQiLCJ1cGRhdGVVc2VyIiwiZGVsZXRlVXNlciIsImdldFByb2R1Y3RzIiwiYWN0aXZlIiwicXVlcnkiLCJ1bmRlZmluZWQiLCJjcmVhdGVQcm9kdWN0IiwicHJvZHVjdERhdGEiLCJnZXRQcm9kdWN0QnlJZCIsInVwZGF0ZVByb2R1Y3QiLCJkZWxldGVQcm9kdWN0IiwiZ2V0Q2FzaFJlZ2lzdGVycyIsInBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwidXNlcklkIiwidG9TdHJpbmciLCJnZXRDYXNoUmVnaXN0ZXIiLCJjcmVhdGVDYXNoUmVnaXN0ZXIiLCJkYXRhIiwidXBkYXRlQ2FzaFJlZ2lzdGVyIiwiZGVsZXRlQ2FzaFJlZ2lzdGVyIiwiZ2V0U2FsZXMiLCJmaWx0ZXJzIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsImNyZWF0ZVNhbGUiLCJzYWxlRGF0YSIsImdldFNhbGVCeUlkIiwidXBkYXRlU2FsZSIsImRlbGV0ZVNhbGUiLCJjb25zdHJ1Y3RvciIsImFwaUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});